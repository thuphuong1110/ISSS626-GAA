{
  "hash": "e41a2c18cca4b1b660e6e652b1d53254",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 1: Geospatial Analytics for Public Good\"\nauthor: \"Nguyen Bao Thu Phuong\"\ndate: \"21 September 2024\" \ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n# Overview\n\n## Setting the scene\n\nAccording to the World Health Organization (WHO) report, road traffic accidents cause 1.19 million deaths annually, with most fatalities occurring in low- and middle-income countries. Vulnerable road users, including pedestrians and motorcyclists, account for over half of these deaths, and road injuries are the leading cause of death for ages 5–29. The economic impact is severe, costing countries 3% of their GDP.\n\nThailand's roads are the deadliest in Southeast Asia, with about 20,000 deaths annually. Between 2014 and 2021, Thailand saw a notable rise in accident frequencies. 19% of all accidents occurs on national highways, with most accidents happening on straight roads and at intersections.\n\n## Objectives\n\nRoad traffic accidents are largely influenced by behavioral factors (driver behavior and performance) and environmental factors (weather and road conditions). While studies using Spatial Point Patterns Analysis (SPPA) have explored these factors, they often overlook temporal elements like season, day in the week, or time during the day.\n\nThis study will focus on discovering factors affecting road traffic accidents in the Bangkok Metropolitan Region (BMR) - one of the most populated metropolitan regions in Thailand, using different spatio-temporal point pattern analysis techniques:\n\n-   Visualize the spatio-temporal dynamics of traffic accidents in BMR using appropriate statistical graphics and geovisualization methods.\n\n-   Perform spatial analysis of traffic accidents using appropriate Network Spatial Point Patterns Analysis methods.\n\n-   Conduct spatio-temporal analysis using appropriate Temporal Network Spatial Point Patterns Analysis methods.\n\n## The Data\n\nFor the purpose of this study, 3 data sets are used:\n\n-   [Thailand Road Accident \\[2019-2022\\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022) on Kaggle: provides statistics on recorded accidents in Thailand from 2019 to 2022. This dataset is in csv format.\n\n-   [Thailand Roads (OpenStreetMap Export)](https://data.humdata.org/dataset/hotosm_tha_roads) on HDX: road network in Thailand in ESRI shapefile format.\n\n-   [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) on HDX: boundaries at different administrative levels in Thailand in ESRI shapefile format.\n\nAll these dataset should be downloaded and store in `data/rawdata` folder under the same folder path with the Quarto document.\n\n# Set up R environment\n\n::: panel-tabset\n## Import R packages\n\nThe below code chunk uses `p_load()` of pacman package to install and load relevant packages into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf,raster, spatstat, tmap, tidyverse, spNetwork, sparr, RColorBrewer)\n```\n:::\n\n\n-   [tmap](https://cran.r-project.org/web/packages/tmap/) for visualizing geospatial data\n\n-   [sf](https://r-spatial.github.io/sf/) for handling geospatial data\n\n-   [tidyverse](https://www.tidyverse.org/) for handling aspatial data\n\n-   [raster](https://rspatial.org/raster/) for handling raster data\n\n-   [spatstat](https://cran.r-project.org/web/packages/spatstat/index.html) for performing Spatial Point Patterns Analysis\n\n-   [sparr](https://tilmandavies.github.io/sparr/index.html) provides functions to estimate fixed and adaptive kernel-smoothed spatial relative risk surfaces via the density-ratio method and perform subsequent inference.\n\n-   [spNetwork](https://cran.r-project.org/web/packages/spNetwork/index.html) provides functions to perform Temporal-Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network.\n\n## Set Seed\n\nWe set the seed to ensure reproducibility and consistency of the remaining analysis and simulations to be done in this study.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2024)\n```\n:::\n\n:::\n\n# Spatial Data Wrangling\n\n## Data Import and Preparation\n\n::: panel-tabset\n### Traffic Accident\n\nThe below code chunk carries out these transformation steps on `thai_road_accident_2019_2022.csv`:\n\n-   read_csv(): import csv file and assign data to a tibble data frame.\n\n-   select(): select relevant columns from the tibble data frame\n\n-   filter(): exclude records with invalid longitude or latitude value\n\n-   mutate(): create additional month/day/time columns from `incident_datetime`\n\n-   st_as_sf(): convert tible data frame into simple feature data frame\n\n-   st_transform(): reprojected the sf data frame to Thailand Projected coordinate system. EPSG is referred from [epsg.io](https://epsg.io/32647).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrdacc_sf = read_csv(\"data/rawdata/thai_road_accident_2019_2022.csv\") %>%\n  select(-c(\"province_th\", \"route\", \"report_datetime\",\"agency\")) %>% # remove irrelevant columns\n  filter(!is.na(longitude) & longitude != \"\",\n         !is.na(latitude) & latitude != \"\") %>%\n  mutate(month_no = month(incident_datetime)) %>%\n  mutate(month_fac = month(incident_datetime,\n                       label = TRUE, abbr = TRUE)) %>%\n  mutate(dayofweek = wday(incident_datetime, week_start = 1)) %>%\n  mutate(dayofyear = yday(incident_datetime)) %>%\n  mutate(hourofday = hour(incident_datetime)) %>%\n  mutate(year = year(incident_datetime)) %>%\n  st_as_sf(coords = c(\"longitude\", \"latitude\"),\n           crs = 4326) %>%\n  st_transform(crs = 32647)\n```\n:::\n\n\nNext we write the result sf data frame to rds format to avoid repeating the initial transformations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(rdacc_sf, \"data/rds/acc.rds\")\n```\n:::\n\n\nThe below code chunk uses `read_rds()` to read in the rds file and filter for accidents in Bangkok Metropolitan Region. The output is assigned to `bmr_acc`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_acc = read_rds(\"data/rds/acc.rds\") %>%\n  filter(province_en %in% c(\"Bangkok\",\"Nakhon Pathom\", \"Pathum Thani\",\"Nonthaburi\", \"Samut Prakan\", \"Samut Sakhon\"))\n```\n:::\n\n\nNext we check the content and CRS of the simple features object and observe the following:\n\n-   The event object `bmr_acc` is already in POINT geometry type with dimension XY, which satisfies the requirement for further Kernel Density Estimate (KDE) analysis.\n\n-   CRS is set to EPSG 32647 as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_acc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 12986 features and 18 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 12,986 × 19\n   acc_code incident_datetime   province_en   vehicle_type        presumed_cause\n *    <dbl> <dttm>              <chr>         <chr>               <chr>         \n 1   571882 2019-01-01 02:25:00 Nakhon Pathom motorcycle          speeding      \n 2   600001 2019-01-01 03:00:00 Nonthaburi    private/passenger … speeding      \n 3   605043 2019-01-01 03:00:00 Samut Prakan  private/passenger … running red l…\n 4   629691 2019-01-01 03:05:00 Bangkok       other               other         \n 5   571887 2019-01-01 04:30:00 Nakhon Pathom motorcycle          speeding      \n 6   599234 2019-01-01 04:45:00 Samut Prakan  motorcycle          driving under…\n 7   599990 2019-01-01 05:30:00 Samut Sakhon  motorcycle          speeding      \n 8   612045 2019-01-01 05:30:00 Nonthaburi    private/passenger … cutting in cl…\n 9   629689 2019-01-01 05:42:00 Bangkok       other               other         \n10   607046 2019-01-01 06:30:00 Pathum Thani  private/passenger … speeding      \n# ℹ 12,976 more rows\n# ℹ 14 more variables: accident_type <chr>, number_of_vehicles_involved <dbl>,\n#   number_of_fatalities <dbl>, number_of_injuries <dbl>,\n#   weather_condition <chr>, road_description <chr>, slope_description <chr>,\n#   month_no <dbl>, month_fac <ord>, dayofweek <dbl>, dayofyear <dbl>,\n#   hourofday <int>, year <dbl>, geometry <POINT [m]>\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(bmr_acc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n```\n\n\n:::\n:::\n\n\nWe check if the data contains any duplicated accident records. The return index is 0 indicates there is no duplicated records.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyDuplicated(bmr_acc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nAs the `Thailand Roads` shapefile from OpenStreetMap contains various road types in Thailand, we visualize the frequency of accidents involving different vehicle types to decide which road types to be included for the scope of this analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = bmr_acc, aes(x = fct_infreq(vehicle_type))) +\n  geom_bar(fill = \"skyblue\", color = \"black\") +  # Bar plot with colored bars\n  labs(title = \"Frequency of Different Vehicle Types\", \n       x = \"Vehicle Type\", \n       y = \"Count\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) \n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nThe above chart shows that the majority of the accidents were caused by motor vehicles, only 0.39 % were caused by bicycle, pedestrian, motorized tricycle and agricultural vehicle as calculated below.\n\nFor the scope of this analysis, we will focus on motor vehicles related accident and road types that allow motor vehicles access only.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filter the records where vehicle_type is either 'pedestrian' or 'bicycle'\nsubset_vehicle <- bmr_acc[bmr_acc$vehicle_type %in% c(\"pedestrian\", \"bicycle\",\"motorized tricycle\",\"tractor/agricultural vehicle\"), ]\n\n# Calculate the percentage & print the result\npercentage <- (nrow(subset_vehicle) / nrow(bmr_acc)) * 100\nprint(paste(\"Percentage of pedestrian and bicycle records:\", round(percentage, 2), \"%\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Percentage of pedestrian and bicycle records: 0.39 %\"\n```\n\n\n:::\n:::\n\n\n### Thailand Subnational Administrative Boundaries\n\nThe below code chunk uses st_read() to imports the administrative boundaries at province level (level 1) and filter for provinces in Bangkok Metropolitan Region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_prov = st_read(dsn = \"data/rawdata\",layer = \"tha_admbnda_adm1_rtsd_20220121\") %>%\n  filter(ADM1_EN %in% c(\"Bangkok\",\"Nakhon Pathom\", \"Pathum Thani\",\"Nonthaburi\", \"Samut Prakan\", \"Samut Sakhon\"))\n```\n:::\n\n\nThe output is written to rds file to avoid repeating initial transformation steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bmr_prov, \"data/rds/bmr_prov.rds\")\n```\n:::\n\n\nNext we read from rds file using `read_rds()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_prov = read_rds(\"data/rds/bmr_prov.rds\")\n```\n:::\n\n\nand reproject to Thailand projected coordinate system using `st_transform()`. The output is assigned to `bmr_boundary`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_boundary = st_transform(bmr_prov, crs = 32647)\n```\n:::\n\n\nChecking the content and CRS of this sf data frame yields the below:\n\n-   The event object `bmr_boundary` is in POLYGON geometry type with dimension XY, which is as expected for boundary object.\n\n-   CRS is set to EPSG 32647 as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_boundary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 587893.5 ymin: 1484414 xmax: 712440.5 ymax: 1579076\nProjected CRS: WGS 84 / UTM zone 47N\n  Shape_Leng Shape_Area       ADM1_EN      ADM1_TH ADM1_PCODE ADM1_REF\n1   2.417227 0.13133873       Bangkok กรุงเทพมหานคร       TH10     <NA>\n2   1.695100 0.07926199  Samut Prakan   สมุทรปราการ       TH11     <NA>\n3   1.251111 0.05323766    Nonthaburi        นนทบุรี       TH12     <NA>\n4   1.884945 0.12698345  Pathum Thani       ปทุมธานี       TH13     <NA>\n5   2.463030 0.17891420 Nakhon Pathom       นครปฐม       TH73     <NA>\n6   1.566369 0.07155983  Samut Sakhon     สมุทรสาคร       TH74     <NA>\n  ADM1ALT1EN ADM1ALT2EN ADM1ALT1TH ADM1ALT2TH  ADM0_EN   ADM0_TH ADM0_PCODE\n1       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n2       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n3       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n4       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n5       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n6       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n        date    validOn    validTo                       geometry\n1 2019-02-18 2022-01-22 -001-11-30 MULTIPOLYGON (((674339.8 15...\n2 2019-02-18 2022-01-22 -001-11-30 MULTIPOLYGON (((687139.8 15...\n3 2019-02-18 2022-01-22 -001-11-30 MULTIPOLYGON (((644817.9 15...\n4 2019-02-18 2022-01-22 -001-11-30 MULTIPOLYGON (((704086 1575...\n5 2019-02-18 2022-01-22 -001-11-30 MULTIPOLYGON (((631987.6 15...\n6 2019-02-18 2022-01-22 -001-11-30 MULTIPOLYGON (((641549.1 15...\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(bmr_boundary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n```\n\n\n:::\n:::\n\n\nWe use **tmap** to plot the output and can see the 6 provinces of BMR has been plotted correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(bmr_boundary) +\n  tm_polygons() +\n  tm_text(\"ADM1_EN\", size = 0.5)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### Thailand Bangkok Metropolitan Region Road\n\nThe below code chunk carries out the following steps:\n\n-   `st_read()`: read in the shapefile exported from OpenStreetMap\n\n-   `st_set_crs()`: as the original datataset CRS is NA, we use st_set_crs() to assign to EPSG 4326 of WGS84 geodetic coordinate system\n\n-   `st_intersection()`: filter for roads inside BMR boundary only.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_road = st_read(dsn = \"data/rawdata\",layer = \"hotosm_tha_roads_lines_shp\") %>%\n  st_set_crs(4326) %>%\n  st_intersection(bmr_prov)\n```\n:::\n\n\nWe write the output into rds file using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bmr_road, \"data/rds/bmr_road.rds\")\n```\n:::\n\n\nAs the OSM data include exhaustive road types (under column `highway`), we will filter for road types that allow motor vehicles access only. According to [WikiProject Thailand](https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Highway_classification), we filter for the below `highway` classification where motorcycle and car can access.\n\nThe below code chunk uses:\n\n-   `read_rds()` to read from rds file\n\n-   `filter()`: filter for relevant road types\n\n-   `st_transform()`: reproject to Thailand Projected CRS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_road_ft = read_rds(\"data/rds/bmr_road.rds\") %>%\n  filter(highway %in% c(\"motorway\", \"motorway_link\", \"trunk\",\"trunk_link\",\"primary\",\"primary_link\",\"secondary\",\"secondary_link\",\"tertiary\",\"tertiary_link\", \"unclassified\",\"living_street\", \"road\", \"residential\")) %>%\n  st_transform(crs = 32647)\n```\n:::\n\n\nWe rrite the transformed road data to rds file using `write_rds()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bmr_road_ft, \"data/rds/network.rds\")\n```\n:::\n\n\nNext we read from rds file using `read_rds()` and assigned the output to `network` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork = read_rds(\"data/rds/network.rds\")\n```\n:::\n\n\nWe use `tm_shape()` and `tm_lines()` to plot the road network for a quick view.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(network) +\n  tm_lines()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nThe network is still too dense to be observable. The frequency of different `highway` classification is plotted as below for further investigation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = network, aes(x = fct_infreq(highway))) +\n  geom_bar(fill = \"skyblue\", color = \"black\") +  # Bar plot with colored bars\n  labs(title = \"Frequency of Different Highway Classes\", \n       x = \"Highway Class\", \n       y = \"Count\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) \n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nIt can be seen that `residential` class takes up the majority number of records. As defined in [WikiProject Thailand](https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Highway_classification), `residential` class includes roads \"within a residential area that gives the public access to one or multiple residences. Also used for roads within a gated housing estate (add access=private). Residential roads are typically short in length and often named.\" As these roads are inside residential area and usually short, we assume the number of traffic accidents happening on this type of road is small.\n\nWe exclude `highway=residential` from the `network` sf object using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork = filter(network, ! highway %in% c(\"residential\"))\n```\n:::\n\n\nChecking the content and CRS of `network` sf data frame yields the below:\n\n-   The object is in GEOMETRY geometry type with dimension XY, while NKDE analysis requires LINESTRING geometry type.\n\n-   CRS is set to EPSG 32647 as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 33100 features and 30 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 590124.8 ymin: 1484506 xmax: 712235 ymax: 1579041\nProjected CRS: WGS 84 / UTM zone 47N\nFirst 10 features:\n                 name                name_en        highway  surface smoothness\n1          ถนนฉลองกรุง     Chalong Krung Road      secondary    paved       <NA>\n3                <NA>                   <NA> secondary_link     <NA>       <NA>\n5          ถนนฉลองกรุง     Chalong Krung Road      secondary concrete       <NA>\n869  ถนนประชาสงเคราะห์   Pracha Songkhro Road       tertiary  asphalt       <NA>\n1030             <NA>                   <NA> secondary_link     <NA>       <NA>\n1099     ถนนวิภาวดีรังสิต Vibhavadi Rangsit Road      secondary     <NA>       <NA>\n1101         ถนนดินแดง         Din Daeng Road        primary     <NA>       <NA>\n1104     ถนนวิภาวดีรังสิต Vibhavadi Rangsit Road      secondary     <NA>       <NA>\n1106         ถนนดินแดง         Din Daeng Road        primary     <NA>       <NA>\n1108             <NA>                   <NA>   primary_link     <NA>       <NA>\n     width lanes oneway bridge layer source          name_th     osm_id\n1     <NA>  <NA>    yes   <NA>  <NA>   <NA>       ถนนฉลองกรุง 1125681229\n3     <NA>  <NA>    yes   <NA>  <NA>   <NA>             <NA>  472283206\n5     <NA>     2    yes    yes     1   Bing       ถนนฉลองกรุง  116847248\n869   <NA>  <NA>   <NA>   <NA>  <NA>   <NA> ถนนประชาสงเคราะห์   25933535\n1030  <NA>  <NA>    yes    yes     1   Bing             <NA>   97092142\n1099  <NA>  <NA>    yes   <NA>  <NA>   <NA>     ถนนวิภาวดีรังสิต  835519345\n1101  <NA>  <NA>    yes   <NA>  <NA>   <NA>         ถนนดินแดง 1055365750\n1104  <NA>  <NA>    yes   <NA>  <NA>   <NA>     ถนนวิภาวดีรังสิต 1306889182\n1106  <NA>  <NA>    yes   <NA>  <NA>   <NA>         ถนนดินแดง 1306889184\n1108  <NA>  <NA>    yes   <NA>  <NA>   <NA>             <NA> 1306889186\n      osm_type Shape_Leng Shape_Area ADM1_EN      ADM1_TH ADM1_PCODE ADM1_REF\n1    ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n3    ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n5    ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n869  ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n1030 ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n1099 ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n1101 ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n1104 ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n1106 ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n1108 ways_line   2.417227  0.1313387 Bangkok กรุงเทพมหานคร       TH10     <NA>\n     ADM1ALT1EN ADM1ALT2EN ADM1ALT1TH ADM1ALT2TH  ADM0_EN   ADM0_TH ADM0_PCODE\n1          <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n3          <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n5          <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n869        <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n1030       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n1099       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n1101       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n1104       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n1106       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n1108       <NA>       <NA>       <NA>       <NA> Thailand ประเทศไทย         TH\n           date    validOn    validTo                       geometry\n1    2019-02-18 2022-01-22 -001-11-30 LINESTRING (693686.1 151979...\n3    2019-02-18 2022-01-22 -001-11-30 LINESTRING (692949.1 151886...\n5    2019-02-18 2022-01-22 -001-11-30 LINESTRING (692810.8 151863...\n869  2019-02-18 2022-01-22 -001-11-30 LINESTRING (668360.2 152245...\n1030 2019-02-18 2022-01-22 -001-11-30 LINESTRING (652536.6 152423...\n1099 2019-02-18 2022-01-22 -001-11-30 LINESTRING (667716.6 152278...\n1101 2019-02-18 2022-01-22 -001-11-30 LINESTRING (667485.1 152210...\n1104 2019-02-18 2022-01-22 -001-11-30 LINESTRING (667822.4 152298...\n1106 2019-02-18 2022-01-22 -001-11-30 LINESTRING (667418.7 152214...\n1108 2019-02-18 2022-01-22 -001-11-30 LINESTRING (667434.6 152210...\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(network)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n```\n\n\n:::\n:::\n\n\nThe below code chunk converts the the geometry type to LINESTRING using `st_cast()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork = st_cast(network, \"LINESTRING\")\n```\n:::\n\n\nWe check if data contains any duplicated record using `anyDuplicated()` . The return index is 0 indicating there is no duplicated records in `network` sf data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyDuplicated(network)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n:::\n\n## Data Wrangling\n\nAs stated in the Objective section, road traffic accidents are generally caused by two main factors: **behavioral** and **environmental**. Behavioral factors, which are often the primary cause, can be divided into driver behavior (driving style) and driver performance (driving skills) (Elander, West, & French, 1993). Environmental factors include conditions like poor visibility due to weather (e.g., heavy rain or fog) and hazardous road features such as sharp bends, slippery slopes, or blind spots.\n\nIn this section, we perform additional mapping on the columns relevant to these factors in `bmr_acc` sf data frame.\n\n::: panel-tabset\n### Accident Presumed Cause\n\nFirst we check the frequency of different accident presume causes using below code chunk:\n\n-   group_by(): group the records by `presumed_cause` column\n\n-   summarise(): returns 1 row representing the count of records under each presumed cause.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncause_counts <- bmr_acc %>%\n  group_by(presumed_cause) %>%\n  summarise(count = n()) %>%\n  ungroup()\ncause_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 40 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 40 × 3\n   presumed_cause                                count                  geometry\n   <chr>                                         <int>            <GEOMETRY [m]>\n 1 abrupt lane change                               59 MULTIPOINT ((603057.8 15…\n 2 brake/anti-lock brake system failure              7 MULTIPOINT ((665762 1511…\n 3 cutting in closely by people/vehicles/animals   621 MULTIPOINT ((595540.6 15…\n 4 dangerous curve                                  14 MULTIPOINT ((640057.9 15…\n 5 debris/obstruction on the road                   29 MULTIPOINT ((640235.4 15…\n 6 disabled vehicle without proper signals           1  POINT (639212.7 1509212)\n 7 disabled vehicle without proper signals/signs     3 MULTIPOINT ((654036.8 15…\n 8 driving in the wrong lane                         6 MULTIPOINT ((623601.1 14…\n 9 driving under the influence of alcohol          118 MULTIPOINT ((607471.8 15…\n10 failure to signal enter/exit parking              5 MULTIPOINT ((622165.9 15…\n# ℹ 30 more rows\n```\n\n\n:::\n:::\n\n\nAs there are many causes with a small counts, the below code chunk is used to map all causes with records count smaller than or equal to 50 to `other cause` to avoid crowding the visualization with too many insignificant variables later. The modified mapping is save in `presumed_cause_rd` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify causes with less than 50 records\nrare_causes <- cause_counts %>%\n  filter(count <= 50) %>%\n  pull(presumed_cause)\n\n# Map those rare causes to \"other cause\"\nbmr_acc <- bmr_acc %>%\n  mutate(presumed_cause_rd = ifelse(presumed_cause %in% rare_causes, \"other cause\", presumed_cause))\n```\n:::\n\n\nWe check the cause count again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncause_counts_rd <- bmr_acc %>%\n  group_by(presumed_cause_rd) %>%\n  summarise(count = n()) %>%\n  ungroup()\ncause_counts_rd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 11 features and 2 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 11 × 3\n   presumed_cause_rd                             count                  geometry\n   <chr>                                         <int>          <MULTIPOINT [m]>\n 1 abrupt lane change                               59 ((603057.8 1533623), (63…\n 2 cutting in closely by people/vehicles/animals   621 ((595540.6 1542724), (59…\n 3 driving under the influence of alcohol          118 ((607471.8 1545956), (61…\n 4 falling asleep                                  221 ((597876.3 1547500), (60…\n 5 other                                           957 ((624456.5 1494214), (63…\n 6 other cause                                     270 ((599469.8 1542071), (60…\n 7 running red lights/traffic signals               96 ((610783.1 1530716), (61…\n 8 speeding                                      10143 ((593843.8 1550868), (59…\n 9 tailgating                                       83 ((622420.1 1491733), (64…\n10 unfamiliarity with the route/unskilled drivi…    53 ((591277.5 1545514), (62…\n11 vehicle equipment failure                       365 ((606366 1562577), (6066…\n```\n\n\n:::\n:::\n\n\nWe can see the individual rare causes are mapped to `other cause` already.\n\n### Accident Weather Condition\n\nFirst we check the frequency of different weather conditions using below code chunk:\n\n-   group_by(): group the records by `weather_condition` column\n\n-   summarise(): returns 1 row representing the count of records under each weather condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_counts <- bmr_acc %>%\n  group_by(weather_condition) %>%\n  summarise(count = n()) %>%\n  ungroup()\nweather_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7 features and 2 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 7 × 3\n  weather_condition count                                               geometry\n  <chr>             <int>                                         <GEOMETRY [m]>\n1 clear             11711 MULTIPOINT ((591277.5 1545514), (593843.8 1550868), (…\n2 dark                 81 MULTIPOINT ((629588.3 1507077), (644784.6 1533981), (…\n3 foggy                 4 MULTIPOINT ((655920.3 1511008), (666583.8 1509141), (…\n4 land slide            1                               POINT (666736.7 1509549)\n5 natural disaster      1                               POINT (650910.3 1540963)\n6 other                22 MULTIPOINT ((639624 1552092), (649315 1550117), (6494…\n7 rainy              1166 MULTIPOINT ((604435.1 1525464), (604930.8 1525557), (…\n```\n\n\n:::\n:::\n\n\nWe can see that 90% of accidents (over total 12,986 records) happened under `clear` weather and 7.7% happened under `rainy` weather. This signifies majority of road accidents in BMR may not be due to weather.\n\nAs other weather condition has relative small counts, we map all these conditions to `other condition` using below code chunk. The modified mapping is saved in `weather_rd` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_other <- c(\"dark\", \"foggy\", \"land slide\", \"natural disaster\", \"other\")\n\n# Map those rare condition to \"other condition\"\nbmr_acc <- bmr_acc %>%\n  mutate(weather_rd = ifelse(weather_condition %in% weather_other, \"other condition\", weather_condition))\n\n# Check the count again\nweather_counts_rd <- bmr_acc %>%\n  group_by(weather_rd) %>%\n  summarise(count = n())\nweather_counts_rd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 3 features and 2 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 3 × 3\n  weather_rd      count                                                 geometry\n  <chr>           <int>                                         <MULTIPOINT [m]>\n1 clear           11711 ((591277.5 1545514), (593843.8 1550868), (595042.2 1550…\n2 other condition   109 ((629588.3 1507077), (639624 1552092), (644784.6 153398…\n3 rainy            1166 ((604435.1 1525464), (604930.8 1525557), (604978 152556…\n```\n\n\n:::\n:::\n\n\nWe can see the remaining conditions are mapped to `other condition` already.\n\n### Road and Slope Condition of Accident\n\nFirst we check the frequency of different road and slope description combination using below code chunk:\n\n-   group_by(): group the records by `road_descroption` and `slope_description` columns\n\n-   summarise(): returns 1 row representing the count of records under each combination.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count the occurrences of each road and slope description combination\nroad_counts <- bmr_acc %>%\n  group_by(road_description, slope_description) %>%\n  summarise(count = n()) %>%\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'road_description'. You can override using\nthe `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate the percentage of occurrences\ntotal_count <- sum(road_counts$count)\nroad_counts <- road_counts %>%\n  mutate(percentage = round((count / total_count) * 100,2))\n\n# View the result\nroad_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 19 features and 4 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 19 × 5\n   road_description slope_description count                  geometry percentage\n * <chr>            <chr>             <int>          <MULTIPOINT [m]>      <dbl>\n 1 connecting to p… other                 8 ((595545.3 1542719), (61…       0.06\n 2 connecting to p… other                43 ((606712.6 1557002), (60…       0.33\n 3 connecting to s… other                 4 ((646878.1 1550240), (66…       0.03\n 4 four-way inters… other                 6 ((616900.4 1556213), (62…       0.05\n 5 grade-separated… other               150 ((654173 1525967), (6560…       1.16\n 6 merge lane       other                11 ((665780.8 1524036), (66…       0.08\n 7 other            other              1004 ((604914.7 1548870), (60…       7.73\n 8 roundabout       other                 3 ((614608.3 1523654), (65…       0.02\n 9 sharp curve      no slope              9 ((627908.6 1522233), (63…       0.07\n10 sharp curve      slope area           32 ((621201.3 1498072), (62…       0.25\n11 straight road    no slope          10221 ((591277.5 1545514), (59…      78.7 \n12 straight road    other               712 ((603057.8 1533623), (61…       5.48\n13 straight road    slope area          151 ((642026.9 1499283), (65…       1.16\n14 t-intersection   other                66 ((599469.8 1542071), (61…       0.51\n15 u-turn area      other                 5 ((641181.3 1509733), (66…       0.04\n16 wide curve       no slope            347 ((605960.9 1537813), (60…       2.67\n17 wide curve       other                90 ((655680.3 1506877), (65…       0.69\n18 wide curve       slope area           51 ((652382.4 1524279), (65…       0.39\n19 y-intersection   other                73 ((629514.6 1526365), (62…       0.56\n```\n\n\n:::\n:::\n\n\nAs there are many road and slope condition combination with small counts, we map all these combinations with records count percentage over total number of cases smaller than 1% to `other condition` keep the focus on the conditions that presented in the majority of the accidents only.\n\nThe below code chunk use `mutate()` to create `road_rd` column , which has `value = other conditions` for accidents under conditions with small counts and `value = road_description-slope_description` otherwise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify conditions with records percentage less than 1%\nrare_conditions <- road_counts %>%\n  filter(percentage < 1) %>%\n  mutate(road_condition = paste(road_description, slope_description, sep = \"-\")) %>%\n  pull(road_condition)\n\n# Map those rare causes to \"other cause\"\nbmr_acc <- bmr_acc %>%\n  mutate(road_condition = paste(road_description, slope_description, sep = \"-\")) %>%\n  mutate(road_rd = ifelse(road_condition %in% rare_conditions, \"other conditions\", road_condition))\n```\n:::\n\n\nWe check the count and percentage in `road_rd` column using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count the occurrences of each road and slop description combination\nroad_counts_rd <- bmr_acc %>%\n  group_by(road_rd) %>%\n  summarise(count = n())\n\n# Calculate the percentage of occurrences\ntotal_count <- sum(road_counts_rd$count)\nroad_counts_rd <- road_counts_rd %>%\n  mutate(percentage = round((count / total_count) * 100,2))\n\n# View the result\nroad_counts_rd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7 features and 3 fields\nGeometry type: MULTIPOINT\nDimension:     XY\nBounding box:  xmin: 591277.5 ymin: 1486846 xmax: 710166.1 ymax: 1576520\nProjected CRS: WGS 84 / UTM zone 47N\n# A tibble: 7 × 4\n  road_rd                             count                  geometry percentage\n* <chr>                               <int>          <MULTIPOINT [m]>      <dbl>\n1 grade-separated intersection/ramps…   150 ((654173 1525967), (6560…       1.16\n2 other conditions                      401 ((595545.3 1542719), (59…       3.09\n3 other-other                          1004 ((604914.7 1548870), (60…       7.73\n4 straight road-no slope              10221 ((591277.5 1545514), (59…      78.7 \n5 straight road-other                   712 ((603057.8 1533623), (61…       5.48\n6 straight road-slope area              151 ((642026.9 1499283), (65…       1.16\n7 wide curve-no slope                   347 ((605960.9 1537813), (60…       2.67\n```\n\n\n:::\n:::\n\n\nWe can see all the rare combinations have been mapped to `other-conditions` already.\n:::\n\n# Exploratory Data Analysis\n\n## Visualize the Geospatial Data\n\nFirst we plot the map of traffic accidents in BMR with overlaying road network using different function of **tmap** package:\n\n-   tm_polygons(): plot the area boundaries\n\n-   tm_dots(): plot each accident as a red dot (col = 'red') on the map\n\n-   tm_lines(): plot the lines to represent the road network in BMR\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(bmr_boundary) + \n  tm_polygons() +\n  tm_shape(bmr_acc) +\n  tm_dots(col = \"red\") +\n  tm_shape(network) +\n  tm_lines()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\nThe above map shows most of the accidents points already lie on the network. Although there are a few points still lying off the network, this number is trivial. We can confirm the `network` sf data frame cover majority of the accident points and can be used for the remaining analysis.\n\n## Visualize Traffic Accidents Data\n\nIn this section, we deep dive into traffic accidents data to understand the trend, severity and related cause of traffic accidents in Bangkok Metropolitan Region from 2019 to 2022.\n\n::: panel-tabset\n### Traffic Accident Trend\n\nTo understand if there is any seasonal factor impacting occurence of traffic accidents in BMR, the below code chunk is uses `ggplot()` to plot the monthly traffic accidents trend by month by year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group data by year and month, and count the number of accidents\naccidents_by_month <- bmr_acc %>%\n  group_by(year, month_no) %>%\n  summarise(num_accidents = n())\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Plot the data\nggplot(accidents_by_month, aes(x = month_no, y = num_accidents, color = factor(year), group = year)) +\n  geom_line() +\n  labs(title = \"Number of Accidents by Month for Each Year\",\n       x = \"Month No\",\n       y = \"Number of Accidents\",\n       color = \"Year\") +\n  scale_x_continuous(breaks = 1:12, labels = month.abb) + # Label months as Jan, Feb, etc.\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\nWe can observe some similarities in the trend across the 4 years:\n\n-   **April** was the month with the highest number of accident in year 2019 and 2021, and second highest in 2022. This may be due to the Songkran festival in April, which is the largest festival in Thailand. The dip in 2020 can be attributed towards travel restriction during Covid.\n\n-   **February-March** and **May-June** were the months with lower number of accidents throughout the year.\n\n-   The number of accidents had an increasing trend from June to **December**.\n\nAs 2022 is the most recent year with available data and the number of accidents shows a concerning increase towards the end of the year, for the scope of this study we will focus on accidents happening in 2022 only.\n\nThe below code chunk uses `filter()` to filter for accidents recorded in 2022.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_acc = bmr_acc |>\n  filter(year == 2022)\n```\n:::\n\n\n### Traffic Accident by Province\n\nTo understand the geopraphic distribution of traffic accidents in BMR, we use `ggplot()` to plot the number of accidents by province as in below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by province and count the number of accidents\naccidents_by_province <- bmr_acc %>%\n  group_by(province_en) %>%\n  summarise(accident_count = n()) %>%\n  ungroup()\n\n# Create a column chart\nggplot(accidents_by_province, aes(x = reorder(province_en, -accident_count), y = accident_count)) +\n  geom_col(fill = \"skyblue\") +\n  geom_text(aes(label = accident_count), vjust = -0.5, color = \"black\", size = 3.5) +  # Add data labels\n  labs(title = \"Number of Accidents by Province\", \n       x = \"Province\", \n       y = \"Number of Accidents\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))  # Rotate x-axis labels for readability\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\nThe column chart shows the first 4 provinces already account for 91% of the total number of accidents in 2022. For the remaining analysis we will focus on these 4 provinces only.\n\nThe below code chunk filter for these 4 provinces and select the relevant columns using `select()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork = network |>\n  filter(ADM1_EN %in% c(\"Bangkok\", \"Pathum Thani\", \"Samut Prakan\", \"Samut Sakhon\")) |>\n  select(c(\"name_en\",\"highway\",\"osm_id\",\"ADM1_EN\"))\n```\n:::\n\n\nThe same filter is applied for the `bmr_acc` and `bmr_boundary` sf dataframe as below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Traffic accident data frame\nbmr_acc = bmr_acc |>\n  filter(province_en %in% c(\"Bangkok\", \"Pathum Thani\", \"Samut Prakan\", \"Samut Sakhon\"))\n\n# Region boundaries data frame\nbmr_boundary = bmr_boundary |>\n  filter(ADM1_EN %in% c(\"Bangkok\", \"Pathum Thani\", \"Samut Prakan\", \"Samut Sakhon\"))\n```\n:::\n\n\nWe plot the map again using functions of tmap and can see the 2 provinces Nontha Buri and Nakhon Pathom are properly excluded.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(bmr_boundary) +\n  tm_polygons() +\ntm_shape(bmr_acc) +\n  tm_dots(col = 'red') +\ntm_shape(network) +\n  tm_lines()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n### Distance to Nearest Neighbor\n\nNow we want to understand the spread of accident points along the network. We snap the points to the network and calculate the distance of each point to its nearest neighbor on the network.\n\nFirst we aggregate the events that are within 30 meters to each other using `aggregate_points()`.\n\n**Note**: for the distance calculation to work, we need to ensure no point shares the exact same location on the network. Hence the points close to each other needs to be aggregated before proceeding further.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbmr_acc$weight <- 1\nbmr_acc_agg <- bmr_acc |>\n  aggregate_points(30 ,weight = \"weight\")\n```\n:::\n\n\nNext the distance of each even to its nearest neighbor on the network is calculated using `network_knn()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn_dists <- network_knn(origins = bmr_acc_agg, \n                         lines = network, \n                         k = 1,\n                         maxdistance = 2000,\n                         line_weight = \"length\",\n                         digits = 2, tol = 0.1, verbose = FALSE)\n```\n:::\n\n\nWe plotting the result using `ggplot()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_histogram(aes(x = knn_dists$distances), fill = \"skyblue\", color = \"black\", bins = 50) + \n  labs(x = \"distance to nearest neighbour (in meters)\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 57 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nThe above histogram shows that there are a few points that are very far from its nearest neighbor. We remove the records with distance larger than 5000 meters and plot the result again using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistances = knn_dists$distances\ndistance_ft = distances[distances < 5000]\n# Plot the histogram\nggplot() + \n  geom_histogram(aes(x = distance_ft), fill = \"skyblue\", color = \"black\", bins = 50) + \n  labs(x = \"Distance to nearest neighbour (in meters)\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\nThe histogram is right skewed with 85.3% of events (after aggregating events within 30 meters) falls within 1 kilometers from its nearest neighbors. This indicates there are certain hot spots on BMR road `network` where traffic accidents occur frequently. We will examine these hot spots in the following TNKDE and NKDE analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate percentage of accidents with nearest neighbor distance lower than 1 kilometer over all accidents in 2022\nlength(distances[distances < 1000])/length(distances)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8528873\n```\n\n\n:::\n:::\n\n:::\n\n# Spatio-Temporal Point Pattern Analysis\n\nA **spatio-temporal point process** is a set of points where each point represents the time and location of an event, such as disease incidence, species sightings, or natural disasters. The analysis of these patterns is increasingly important due to the growth of geographically and temporally indexed data. In the past decade, numerous methods for spatio-temporal point pattern analysis have been developed and implemented in R.\n\nWe will use the **Spatio-Temporal Kernel Density Estimate** (STKDE) method to understand the spatio-temporal dynamics of road accidents in Thailand across different provinces and time during 2022.\n\n## Visualize geographic distribution of traffic accident by month\n\nAs we observe some seasonality in the number of traffic accidents by month in the previous section, we further investigate if there is any difference in the location of those accidents by month.\n\nThe below code chunk uses multiple functions of **tmap** to plot the accidents by month. Each accident is represented by a red dot and each province boundary is filled by a different color.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(bmr_boundary)+\n  tm_fill(col = \"ADM1_EN\", palette = 'Pastel2') +\n  tm_legend(width = 0.5, height = 0.5) +\ntm_shape(network) +\n  tm_lines(alpha = 0.5) +\ntm_shape(bmr_acc) +\n  tm_dots(size = 0.1, col = 'red') +\ntm_facets(by=\"month_fac\", \n            free.coords=FALSE, \n            drop.units = TRUE)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\nThe above maps show that the locations of accidents resembles almost the same pattern across all the months, with many points clustered in these 3 parts of the road network:\n\n-   Center of Bangkok\n\n-   Along the vertical road connecting Pathum Thani, Bangkok and Samut Prakan province\n\n-   Along the horizontal road connecting Samut Sakhon and Bangkok\n\n## Compute STKDE for different time dimensions\n\nIn this section, we explore how to compute STKDE using `spattemp.density()`of **sparr** package.\n\nAs `spattemp.density()` requires the object in ppp class, first we create an owin object from `bmr_boundary` to define the observation window for the ppp object using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_owin <- as.owin(bmr_boundary)\nacc_owin\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nwindow: polygonal boundary\nenclosing rectangle: [611104.4, 712440.5] x [1484413.7, 1579076.3] units\n```\n\n\n:::\n:::\n\n\nNext, `class()` of base R is used to confirm if the output is indeed an owin object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(acc_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"owin\"\n```\n\n\n:::\n:::\n\n\n::: panel-tabset\n### Compute STKDE by month\n\n#### Create ppp object\n\nThe code chunk below select only the necessary fields (`month_no`) from the `bmr_acc` sf data frame and conver to ppp object using `as.ppp()`. This is because `as.ppp()` function only requires the mark field and geometry field from sf data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_month_ppp = bmr_acc |>\n  select(month_no) |>\n  as.ppp()\n```\n:::\n\n\nNext we include owin object and check if the output `acc_month_owin` is in the correct object class. We can see the object is already in ppp class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_month_owin <- acc_month_ppp[acc_owin]\nsummary(acc_month_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  3283 points\nAverage intensity 6.70773e-07 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 10 decimal places\n\nmarks are numeric, of type 'double'\nSummary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    4.00    7.00    7.05   10.00   12.00 \n\nWindow: polygonal boundary\nsingle connected closed polygon with 15150 vertices\nenclosing rectangle: [611104.4, 712440.5] x [1484413.7, 1579076.3] units\n                     (101300 x 94660 units)\nWindow area = 4894350000 square units\nFraction of frame area: 0.51\n```\n\n\n:::\n:::\n\n\n`plot()` of base R is used to plot the owin object. The output map shows proper province boundaries and marked points of 12 months.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(acc_month_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\n#### Compute Spatio-temporal KDE\n\nNext, `spattemp.density()` of **sparr** package is used to compute the STKDE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_month_stkde <- spattemp.density(acc_month_owin)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(acc_month_stkde)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 3953.323 (spatial)\n  lambda = 0.0301 (temporal)\n\nNo. of observations\n  3283 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [611104.4, 712440.5] x [1484414, 1579076]\n\nTemporal bound\n  [1, 12]\n\nEvaluation\n  128 x 128 x 12 trivariate lattice\n  Density range: [3.272962e-25, 3.865178e-09]\n```\n\n\n:::\n:::\n\n\n`plot()` of base R is used to plot the spatio-temporal KDE between January 2022 - December 2022 using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntims <- c(1,2,3,4,5,6,7,8,9,10,11,12)\npar(mfcol=c(4,3), mar = c(2, 2, 2, 2))\nfor(i in tims){ \n  plot(acc_month_stkde, i,\n       override.par=FALSE,\n       fix.range=TRUE, \n       main=paste(\"KDE at month\",i))\n}\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\nWe can observe the highest density in December in Bangkok and Samut Sakhon area, followed by January. From August to November, the density spread more equally across the 4 provinces.\n\nThailand experiences 3 main seasons:\n\n-   The wet season from May to October\n\n-   The cool season from November to February\n\n-   The hot season from March to May\n\nWe can observe that the hot and wet season have lower STKDE compared versus cool season (especially in January and December). This can be partly contributed to cool season being high season for travelling in those areas with high density.\n\n### Compute STKDE by day of week\n\n#### Create ppp object\n\nThe code chunk below select only the necessary fields (`dayofweek`) from the `bmr_acc` sf data frame and conver to ppp object using `as.ppp()`. This is because `as.ppp()` function only requires the mark field and geometry field from sf data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_day_ppp <- bmr_acc |> \n  select(dayofweek) |>\n  as.ppp()\n```\n:::\n\n\nNext we include owin object and check if the output `acc_day_owin` is in the correct object class. We can see the object is already in ppp class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_day_owin <- acc_day_ppp[acc_owin]\nsummary(acc_day_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  3283 points\nAverage intensity 6.70773e-07 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 10 decimal places\n\nmarks are numeric, of type 'double'\nSummary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.000   2.000   4.000   4.077   6.000   7.000 \n\nWindow: polygonal boundary\nsingle connected closed polygon with 15150 vertices\nenclosing rectangle: [611104.4, 712440.5] x [1484413.7, 1579076.3] units\n                     (101300 x 94660 units)\nWindow area = 4894350000 square units\nFraction of frame area: 0.51\n```\n\n\n:::\n:::\n\n\n`plot()` of base R is used to plot the owin object. The output map shows proper province boundaries and marked points of 7 days in a week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(acc_day_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\n#### Compute Spatio-temporal KDE\n\nNext, `spattemp.density()` of **sparr** package is used to compute the STKDE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_day_stkde <- spattemp.density(acc_day_owin)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(acc_day_stkde)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 3953.323 (spatial)\n  lambda = 0.013 (temporal)\n\nNo. of observations\n  3283 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [611104.4, 712440.5] x [1484414, 1579076]\n\nTemporal bound\n  [1, 7]\n\nEvaluation\n  128 x 128 x 7 trivariate lattice\n  Density range: [1.848561e-24, 1.301055e-08]\n```\n\n\n:::\n:::\n\n\n`plot()` of base R is used to plot the spatio-temporal KDE for each day in a week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntims <- c(1,2,3,4,5,6,7)\nwdays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\npar(mfcol=c(3,3), mar = c(2, 2, 2, 2))\nfor(i in tims){ \n  plot(acc_day_stkde, i,\n       override.par=FALSE,\n       fix.range=TRUE, \n       main=paste(\"KDE on\",wdays[i]))\n}\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\nThe above maps show that all 4 provinces have areas with high density on Monday (highest in Bangkok), follow by Sunday where high density areas are more spread out. The density is lower during middle of the week (Tuesday to Thursday) and starts to pick up towards the weekend (Friday to Sunday).\n\n### Compute STKDE by hour of day\n\n#### Create ppp object\n\nThe code chunk below select only the necessary fields (`hourofday`) from the `bmr_acc` sf data frame and conver to ppp object using `as.ppp()`. This is because `as.ppp()` function only requires the mark field and geometry field from sf data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_hr_ppp <- bmr_acc |> \n  select(hourofday) |>\n  as.ppp()\n```\n:::\n\n\nNext we include owin object and check if the output `acc_hr_owin` is in the correct object class. We can see the object is already in ppp class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_hr_owin <- acc_hr_ppp[acc_owin]\nsummary(acc_hr_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMarked planar point pattern:  3283 points\nAverage intensity 6.70773e-07 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 10 decimal places\n\nmarks are numeric, of type 'integer'\nSummary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    0.0     8.0    13.0    12.5    18.0    23.0 \n\nWindow: polygonal boundary\nsingle connected closed polygon with 15150 vertices\nenclosing rectangle: [611104.4, 712440.5] x [1484413.7, 1579076.3] units\n                     (101300 x 94660 units)\nWindow area = 4894350000 square units\nFraction of frame area: 0.51\n```\n\n\n:::\n:::\n\n\n`plot()` is used to plot the owin object to examine the correctness of the output object.The output map shows proper province boundaries and marked points of 24 hours in a day.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(acc_hr_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n:::\n\n\n#### Compute Spatio-temporal KDE\n\nNext, `spattemp.density()` of **sparr** package is used to compute the STKDE.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_hr_stkde <- spattemp.density(acc_hr_owin)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCalculating trivariate smooth...Done.\nEdge-correcting...Done.\nConditioning on time...Done.\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(acc_hr_stkde)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatiotemporal Kernel Density Estimate\n\nBandwidths\n  h = 3953.323 (spatial)\n  lambda = 0.0806 (temporal)\n\nNo. of observations\n  3283 \n\nSpatial bound\n  Type: polygonal\n  2D enclosure: [611104.4, 712440.5] x [1484414, 1579076]\n\nTemporal bound\n  [0, 23]\n\nEvaluation\n  128 x 128 x 24 trivariate lattice\n  Density range: [1.091345e-26, 4.371593e-10]\n```\n\n\n:::\n:::\n\n\n`plot()` of base R is used to plot the spatio-temporal KDE of the first half of the day (from 0 AM to 12 PM).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntims <- c(0,1,2,3,4,5,6,7,8,9,10,11)\npar(mfcol=c(4,3), mar = c(2, 2, 2, 2))\nfor(i in tims){ \n  plot(acc_hr_stkde, i,\n       override.par=FALSE,\n       fix.range=TRUE, \n       main=paste(\"KDE at hour\",i))\n}\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n:::\n\n\nThe highest density can be observed at midnight ( around 0 AM) and from 8AM to 11:59AM.\n\nWe continue to use `plot()` of base R to plot the STKDE of the second half of the day.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntims <- c(12,13,14,15,16,17,18,19,20,21,22,23)\npar(mfcol=c(4,3), mar = c(2, 2, 2, 2))\nfor(i in tims){ \n  plot(acc_hr_stkde, i,\n       override.par=FALSE,\n       fix.range=TRUE, \n       main=paste(\"KDE at hour\",i))\n}\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-65-1.png){width=672}\n:::\n:::\n\n\nFor the remainder of the day, high density can be observed during lunch time (12PM - 13PM), in the evening (16PM - 19PM) and late night (22PM -23PM).\n:::\n\n# Network Spatial Point Patterns Analysis\n\n## Prepare the lixels objects and generate line centre points\n\nBefore computing NKDE, the SpatialLines object needs to be divided into lixels (line pixels) with a specified minimum distance. This can be done using the `lixelize_lines()` function from the spNetwork package, as shown in the code chunk below.\n\nAccording to the nearest neighbor distance plotted above, the smallest network distance between 2 accident points is under 100 meters. The lixel length and mindist should be larger than 100 meters to ensure these cases can be captured.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlixels <- lixelize_lines(network, \n                         800, \n                         mindist = 400)\n```\n:::\n\n\nThe followings are observed from the above code chunk.\n\n-   The length of each lixel (`lx_length`) is set to 800 meters.\n\n-   The minimum length of a lixel (`mindist`) is set to 400 meters.\n\nAfter cutting, if the length of the final lixel is shorter than the minimum distance, it is merged with the previous lixel. If mindist = NULL, then it defaults to maxdist/10. Segments that are already shorter than the minimum distance are left unmodified.\n\nNote: The lixelize_lines.mc() function offers multicore support for this process.\n\nNext, `lines_center()` of **spNetwork** is used to generate a SpatialPointsDataFrame (i.e. `samples`) with line centre points as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- lines_center(lixels)\n```\n:::\n\n\nThese points are located at center of the lixel based on the length of the lixel.\n\n## Perform NKDE\n\nNKDE is computed using below code chunk, using the following key arguments:\n\n-   kernel_name = \"quartic\": ensure no negative value returned.\n\n-   method = \"simple\": for faster calculation given the data size. Since the `network` contains many intersections, we acknowledge this simple method may overestimate the density at road intersections.\n\n-   adaptive = FALSE and bw = 500: use fixed bandwidth of 500 meters\n\n-   agg = 30: aggregate accident points within 30 meters of each other\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate NKDE\ndensities <- nkde(network, \n                  events = bmr_acc,\n                  w = rep(1, nrow(bmr_acc)),\n                  samples = samples,\n                  kernel_name = \"quartic\",\n                  bw = 500,\n                  adaptive = FALSE,\n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(2,2), \n                  max_depth = 8,\n                  agg = 30, \n                  sparse = TRUE,\n                  verbose = FALSE)\n```\n:::\n\n\nThe below code chunk performs the following steps:\n\n-   Assign the calculated densities to column `density` in `samples` sf data frame and multiply by 1000 to convert to density by km.\n\n-   Plot the density value for each lixel centre using multiple functions of **tmap**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples$density <- densities\n\n# rescaling to help the mapping\nsamples$density <- samples$density*1000\n\nsamples2 <- samples[order(samples$density),]\n\ncolorRamp <- brewer.pal(n = 10, name = \"Spectral\")\ncolorRamp <- rev(colorRamp)\n\ntitle <- paste0(\"Traffic accident density by km in 2022,\",\n                \"\\nwithin a radius of 500 metres\")\n\ntm_shape(bmr_boundary) +\n  tm_polygons() +\ntm_shape(network) + \n  tm_lines(\"black\") + \n  tm_shape(samples2) + \n  tm_dots(\"density\", style = \"cont\", palette = colorRamp, n = 5, size = 0.1) + \n  tm_layout(legend.outside = TRUE, \n            main.title = title , main.title.size = 1)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-69-1.png){width=672}\n:::\n:::\n\n\nWe can see from the above map accidents density is higher across certain roads:\n\n-   The vertical road connecting Samut Prakan, Bangkok and Pathum Thani.\n\n-   The horizontal roads connecting Samut Sakhon, Bangkok and Samut Prakan. There are some hot spot on the road in Samut Prakan province as well.\n\n## Network Constrained G- and K-Function Analysis\n\nIn this section, we perform complete spatial randomness (CSR) test using `kfunctions()` of spNetwork package. The null hypothesis is defined as:\n\nH0: The observed spatial point events (i.e traffic accidents) are randomly distributed over the street `network` in the 4 provinces in BMR.\n\nThe CSR test assumes a binomial point process, meaning the centres are randomly and independently distributed. If rejected, it indicates the centres are spatially dependent and form nonrandom patterns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkfun_acc <- kfunctions(network, \n                             bmr_acc,\n                             start = 0, \n                             end = 1500, \n                             step = 100, \n                             width = 500,\n                             agg = 30,\n                             nsim = 29, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n```\n:::\n\n\n**Note**: 9 key arguments used in above code chunk:\n\n-   lines: A feature collection of linestrings representing the underlying network. The geometries must be simple Linestrings.\n\n-   points: A `sf` data frame representing points on the network. These points will be snapped on their nearest line.\n\n-   start: A double, the start value for evaluating the k and g functions.\n\n-   end: A double, the last value for evaluating the k and g functions.\n\n-   step: A double, specifying the interval between evaluations of the k and g functions.\n\n-   width: The width of each donut for the g-function.\n\n-   nsim: An integer for the number of Monte Carlo simulations. Typically, more than 50 simulations are needed for inference.\n\n-   resolution: A value to reduce calculation time when simulating random points by splitting edges and selecting vertices.\n\n-   conf_int: A double for setting the confidence interval (default is 0.05).\n\nFor more details on these arguments, refer to the spNetwork user guide.\n\nThe output of kfunctions() is a list containing:\n\n-   `plotkA`: A ggplot2 object representing the k-function values.\n\n-   `plotgA`: A ggplot2 object representing the g-function values.\n\n-   `valuesA`: A DataFrame containing the data used to generate the plots.\n\nFor example, the ggplot2 object of k-function can be visualized using the following code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkfun_acc$plotk\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-71-1.png){width=672}\n:::\n:::\n\n\nThe blue line is the empirical network K-function of traffic accidents in the 4 provinces in BMR. The gray envelop represents the results of the 30 simulations in the confidence interval 2.5% - 97.5%. Since the blue line segment is way above the gray area, we can infer that the accidents are more clustered than what can be expected from a random distribution.\n\nThe below code chunk is used to plot the G function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkfun_acc$plotg\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-72-1.png){width=672}\n:::\n:::\n\n\nThe G-function also demonstrates a clustered distribution. For distance lower than 1 kilometer, a local maximum is observed between 250 to 350 meters. This is consistent with the observations that certain part of the road networks have significantly higher density compared to others.\n\n## Analyze Accidents at high NKDE lixels\n\nFirst we assign the calculated NKDE to `lixel` sf data frame and multiply by 1000 to convert to density per km using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlixels$density = densities*1000\n```\n:::\n\n\nNext we use `summary()` to check the quantile distribution of `density` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(lixels$density)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. \n0.0000000 0.0000000 0.0000000 0.0009879 0.0000000 0.1394524 \n```\n\n\n:::\n:::\n\n\nIn this section, we will focus on accidents happening at lixels with density higher than the mean. This is to understand which factors contribute to those parts of the road with above average accident density.\n\nWe remove the geometry column from `lixels` and create a new data frame `lixels_df` for easier data frame manipulation later on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlixels_df = st_drop_geometry(lixels)\n```\n:::\n\n\nThe below code chunk performs the following steps:\n\n-   Snaps accident points to the nearest lixel within 50 meters using `snapPointsToLines2()` and return the respective `lineID` of the closest lixel.\n\n-   `left_join()` with lixels_df to bring in the density values and other road attributes.\n\n-   Filter for accidents snapped to lixels with density above average.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnapped_accidents = snapPointsToLines2(\n  bmr_acc,\n  lixels,\n  idField = \"lineID\",\n  snap_dist = 50) |>\n  left_join(lixels_df, by = c(\"nearest_line_id\" = \"lineID\")) |>\n  filter(density > 0.0009879)\n```\n:::\n\n\n### Environmental Factors\n\nThe environmental factors: road type, weather condition and road condition are visualized using `ggplot()` as in below code chunks.\n\n::: panel-tabset\n#### Road Type\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by road type and count the number of accidents\naccidents_by_road_type <- snapped_accidents %>%\n  group_by(highway) %>%\n  summarise(accident_count = n()) %>%\n  ungroup()\n\n# Create a column chart\nggplot(accidents_by_road_type, aes(x = reorder(highway, -accident_count), y = accident_count)) +\n  geom_col(fill = \"skyblue\") +\n  geom_text(aes(label = accident_count), vjust = -0.5, color = \"black\", size = 3.5) +  # Add data labels\n  labs(title = \"Number of Accidents by Road Type\", \n       x = \"Road Type\", \n       y = \"Number of Accidents\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-77-1.png){width=672}\n:::\n:::\n\n\nThe plot shows more than half of the accidents in 2022 happened on the motorway.\n\n#### Weather Condition\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by condition and count the number of accidents\naccidents_by_weather <- snapped_accidents %>%\n  group_by(weather_rd) %>%\n  summarise(accident_count = n()) %>%\n  ungroup()\n\n# Create a column chart\nggplot(accidents_by_weather, aes(x = reorder(weather_rd, -accident_count), y = accident_count)) +\n  geom_col(fill = \"skyblue\") +\n  geom_text(aes(label = accident_count), vjust = -0.5, color = \"black\", size = 3.5) +  # Add data labels\n  labs(title = \"Number of Accidents by Weather Condition\", \n       x = \"Weather Condition\", \n       y = \"Number of Accidents\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-78-1.png){width=672}\n:::\n:::\n\n\nThe above plot shows that 90% of the accidents in 2022 happened under clear weather.\n\n#### Road Condition\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by condition and count the number of accidents\naccidents_by_road <- snapped_accidents %>%\n  group_by(road_rd) %>%\n  summarise(accident_count = n()) %>%\n  ungroup()\n\n# Create a column chart\nggplot(accidents_by_road, aes(x = reorder(road_rd, -accident_count), y = accident_count)) +\n  geom_col(fill = \"skyblue\") +\n  geom_text(aes(label = accident_count), vjust = -0.5, color = \"black\", size = 3.5) +  # Add data labels\n  labs(title = \"Number of Accidents by Road Condition\", \n       x = \"Road Condition\", \n       y = \"Number of Accidents\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-79-1.png){width=672}\n:::\n:::\n\n\nThe chart shows that 72.4% of the accidents happened on straight road with no slope.\n:::\n\n### Behavioural Factors\n\nThe behavioral factors from presumed cause are visualized using `ggplot()` as in below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by condition and count the number of accidents\naccidents_by_cause <- snapped_accidents %>%\n  group_by(presumed_cause_rd) %>%\n  summarise(accident_count = n()) %>%\n  ungroup()\n\n# Create a column chart\nggplot(accidents_by_cause, aes(x = reorder(presumed_cause_rd, -accident_count), y = accident_count)) +\n  geom_col(fill = \"skyblue\") +\n  geom_text(aes(label = accident_count), vjust = -0.5, color = \"black\", size = 3.5) +  # Add data labels\n  labs(title = \"Number of Accidents by Presumed Cause\", \n       x = \"Presumed Cause\", \n       y = \"Number of Accidents\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-80-1.png){width=672}\n:::\n:::\n\n\nThe chart shows 72% of accidents was due to speeding.\n\n# Temporal Network Spatial Point Pattern Analysis\n\n## Temporal Dimension\n\nFirst we derive the start of each month for year 2022 to use as label for the later maps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- as.POSIXct(\"2022/01/01\", format = \"%Y/%m/%d\")\nmonths <- as.character(1:12)\nmonths <- ifelse(nchar(months)==1, paste0(\"0\", months), months)\nmonths_starts_labs <- paste(\"2022/\",months,\"/01\", sep = \"\")\nmonths_starts_num <- as.POSIXct(months_starts_labs, format = \"%Y/%m/%d\")\nmonths_starts_num <- difftime(months_starts_num, start, units = \"days\")\nmonths_starts_num <- as.numeric(months_starts_num)\nmonths_starts_labs <- gsub(\"2022/\", \"\", months_starts_labs, fixed = TRUE)\n```\n:::\n\n\nNext we calculate the kernel density values in time for several bandwidths using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- rep(1,nrow(bmr_acc))\nsamples_t <- seq(0, max(bmr_acc$dayofyear), 1)\n\ntime_kernel_values <- data.frame(\n  bw_10 = tkde(bmr_acc$dayofyear, w = w, samples = samples_t, bw = 10, kernel_name = \"quartic\"),\n  bw_20 = tkde(bmr_acc$dayofyear, w = w, samples = samples_t, bw = 20, kernel_name = \"quartic\"),\n  bw_30 = tkde(bmr_acc$dayofyear, w = w, samples = samples_t, bw = 30, kernel_name = \"quartic\"),\n  bw_40 = tkde(bmr_acc$dayofyear, w = w, samples = samples_t, bw = 40, kernel_name = \"quartic\"),\n  bw_50 = tkde(bmr_acc$dayofyear, w = w, samples = samples_t, bw = 50, kernel_name = \"quartic\"),\n  bw_60 = tkde(bmr_acc$dayofyear, w = w, samples = samples_t, bw = 60, kernel_name = \"quartic\"),\n  time = samples_t\n)\n\ndf_time <- reshape2::melt(time_kernel_values,id.vars = \"time\")\ndf_time$variable <- as.factor(df_time$variable)\n\nggplot(data = df_time) + \n  geom_line(aes(x = time, y = value)) +\n  scale_x_continuous(breaks = months_starts_num, labels = months_starts_labs) +\n  facet_wrap(vars(variable), ncol=2, scales = \"free\") + \n  theme(axis.text = element_text(size = 5))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-82-1.png){width=672}\n:::\n:::\n\n\nWe can see that a bandwidth between 30 and 40 days can capture the fluctuations and the trend in traffic accidents throughout 2022: the increase in traffic accident during mid of April (Songkran festival), followed by a decrease until Jun, before the number of accidents starts to increase until the end of the year.\n\n## Spatial Temporal Bandwidth Selection\n\nThe cross validation likelihood of different network and time bandwiths are calculated using `bw_tnkde_cv_likelihood_calc()` as in below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv_scores <- bw_tnkde_cv_likelihood_calc(\n  bws_net = seq(500,1000,100),\n  bws_time = seq(20,60,10),\n  lines = network,\n  events = bmr_acc,\n  time_field = \"dayofyear\",\n  w = rep(1, nrow(bmr_acc)),\n  kernel_name = \"quartic\",\n  method = \"simple\",\n  diggle_correction = FALSE,\n  study_area = NULL,\n  max_depth = 8,\n  digits = 2,\n  tol = 0.1,\n  agg = 30,\n  sparse=TRUE,\n  grid_shape=c(1,1),\n  sub_sample=1,\n  verbose = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncv_scores\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            20        30        40        50        60\n500  -394.7186 -334.0445 -299.0691 -274.7406 -252.7279\n600  -374.2905 -313.2305 -277.8549 -254.1699 -232.1701\n700  -353.0463 -293.8778 -258.3238 -235.6832 -213.6953\n800  -333.0546 -275.9970 -239.6473 -218.0638 -196.2973\n900  -316.8013 -261.2312 -222.6306 -201.8828 -182.2077\n1000 -300.9982 -251.6730 -213.0711 -192.3536 -172.2757\n```\n\n\n:::\n:::\n\n\nAccording to this “leave one out cross validation” method, the bandwidths of 1000 metres and 60 days has the lowest cross validation score and are chosen to be the optimal bandwidth for further density calculation.\n\n## Perform Temporal Network Kernel Density Estimate (TNKDE)\n\nThe TNKDE is calculated using below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# choosing sample in times (every 30 days)\nsample_time <- seq(0, max(bmr_acc$dayofyear), 30)\n\n# calculating densities\ntnkde_densities <- tnkde(lines = network,\n                   events = bmr_acc,\n                   time_field = \"dayofyear\",\n                   w = rep(1, nrow(bmr_acc)), \n                   samples_loc = samples,\n                   samples_time = sample_time, \n                   kernel_name = \"quartic\",\n                   bw_net = 1000, bw_time = 60,\n                   method = \"simple\",\n                   div = \"bw\", max_depth = 8,\n                   digits = 2, tol = 0.01,\n                   agg = 30, grid_shape = c(2,2), \n                   verbose  = FALSE)\n```\n:::\n\n\nWe add the TNKDE of every 30 days to the `samples` sf data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples$tnkde_30 = tnkde_densities[,2]\nsamples$tnkde_60 = tnkde_densities[,3]\nsamples$tnkde_90 = tnkde_densities[,4]\nsamples$tnkde_120 = tnkde_densities[,5]\nsamples$tnkde_150 = tnkde_densities[,6]\nsamples$tnkde_180 = tnkde_densities[,7]\nsamples$tnkde_210 = tnkde_densities[,8]\nsamples$tnkde_240 = tnkde_densities[,9]\nsamples$tnkde_270 = tnkde_densities[,10]\nsamples$tnkde_300 = tnkde_densities[,11]\nsamples$tnkde_330 = tnkde_densities[,12]\nsamples$tnkde_360 = tnkde_densities[,13]\n```\n:::\n\n\nWe use different functions of **tmap** to plot the map for each sample in time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the last 12 columns' names\ncols_to_plot <- tail(colnames(samples), 12)\n# Plot the map for each column\ntm_shape(bmr_boundary) +\n    tm_polygons() +\n  tm_shape(samples) + \n    tm_dots(col = cols_to_plot, style = \"kmeans\", palette = \"Reds\",  n=10, size = 0.05) + \n  tm_layout(legend.show = FALSE, \n            title = cols_to_plot , title.size = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The value range of the variable \"tnkde_90\" is less than 1e-9\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The value range of the variable \"tnkde_120\" is less than 1e-9\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The value range of the variable \"tnkde_210\" is less than 1e-9\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The value range of the variable \"tnkde_360\" is less than 1e-9\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-87-1.png){width=672}\n:::\n:::\n\n\nThe location of many of the hotspots stay along the same roads across different points in time:\n\n-   Several hotspots detected along the vertical road connecting Samut Prakan, Bangkok and Pathum Thani province. Refer to the maps on TNKDE at 60 days, 150 to 180 days, 240 to 300 days.\n\n-   Several hotspots detected along the horizontal road connecting Bangkok and Samut Sakhon province. Refer to the maps on TNKDE at 240 to 330 days.\n\n# Conclusions and Future Improvements\n\n## Factors affecting Traffic Accidents\n\nThe above analysis highlights a few key factors affecting road traffic accidents in the 4 provinces of BMR:\n\n-   Environmental factors: do not seem to play an important role as majority of the accidents happened under clear weather (90%) and on straigh road with no slope (72%).\n\n-   **Driver behaviors**: is an important factor as 72% of the accidents recorded was due to speeding.\n\n-   **Spatial factor**: Network Constrained G- and K-Function results confirm the clustered distribution of accidents in BMR.\n\n**On Spatial temporal factors**\n\n-   **Month in year**: High STKDE in in December in Bangkok and Samut Sakhon area, followed by January. From August to November, the density spread more equally across the 4 provinces. Cool season (especially in January and December) has the highest density, this can be partly due to this season being high season for tourism in Thailand.\n\n-   **Day in week**: All 4 provinces have areas with high density on Monday (highest in Bangkok), followed by Sunday where high density areas are more spread out. The density is lower during middle of the week (Tuesday to Thursday) and starts to pick up towards the weekend (Friday to Sunday).\n\n-   **Hour of day**: The highest density can be observed at late night (22PM to 0 AM of the next day) and from 8AM to 11:59AM. For the remainder of the day, high density can be observed during lunch time (12PM - 13PM) and in the evening (16PM - 19PM).\n\n-   The **TNKDE** maps show many of the hotspots stay along the same roads across different points in time: the vertical road connecting Samut Prakan, Bangkok and Pathum Thani province and the horizontal road connecting Bangkok and Samut Sakhon province.\n\n## Future Improvement\n\nAs I encountered certain computational capacity constraint given the data size, the below improvements can be done on the analysis of the accidents spatial temporal distribution in BMR:\n\n-   As the accidents distribution is clustered, using adaptive bandwith instead of fixed bandwidth for KDE methods may avoid underestimating the density of areas with lower number of accidents.\n\n-   User method = \"continuous\" instead of \"simple\" since the road network in BMR contains many intersections.\n\n-   Use cross validation method for bandwidth selection to allow for a more data-driven approach when selecting bandwidth.\n\n-   Increase the number of simulations to calculate network constrained G and K functions for a more comprehensive range of comparison.\n\n# Reference\n\nJeremy Gelb (2024). [Temporal Network Kernel Density Estimate](https://jeremygelb.github.io/spNetwork/articles/TNKDE.html)\n\nJeremy Gelb (2024). [K-nearest neighbour adaptive bandwidth](https://jeremygelb.github.io/spNetwork/articles/web_vignettes/AdaptiveBW.html)\n\nJeremy Gelb (2024). [Network k Functions](https://jeremygelb.github.io/spNetwork/articles/KNetworkFunctions.html)\n\nJeremy Gelb (2024). [Network Kernel Density Estimate](https://jeremygelb.github.io/spNetwork/articles/NKDE.html)\n\nTin Seong Kam (2024). [Spatio-Temporal Point Patterns Analysis](https://r4gdsa.netlify.app/chap06) From R for Geospatial Data Science and Analytics\n\nTin Seong Kam (2024). [Network Constrained Spatial Point Patterns Analysis](https://r4gdsa.netlify.app/chap07)\n\nWikiProject Thailand. [WikiProject Thailand](https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Highway_classification)\n\nWikipedia. [Bangkok Metropolitan Region](https://en.wikipedia.org/wiki/Bangkok_Metropolitan_Region)\n",
    "supporting": [
      "Take-home_Ex01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}