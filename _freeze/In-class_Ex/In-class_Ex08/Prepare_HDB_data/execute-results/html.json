{
  "hash": "26a8ffe741586d1cbd630c1ae6e430cd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 3: Preparing HDB data for Geographically Weighted Predictive Model\"\nauthor: \"Nguyen Bao Thu Phuong\"\ndate: \"21 October 2024\" \ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n# Import R Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, httr, jsonlite, rvest)\n```\n:::\n\n\n-   rvest: use for web crawling\n\n-   jsonlite: to convert json file to dataframe format\n\n-   tidyverse & sf: further data manipulation\n\n# Import the Data\n\nFirst we load in the Resale data from January 2023 to September 2024.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale <- read_csv(\"data/rawdata/resale.csv\") %>%\n  filter(month >= \"2023-01\" & month <= \"2024-09\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 192234 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (8): month, town, flat_type, block, street_name, storey_range, flat_mode...\ndbl (3): floor_area_sqm, lease_commence_date, resale_price\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_tidy <- resale %>%\n  mutate(address = paste(block,street_name)) %>%\n  mutate(remaining_lease_yr = as.integer(\n    str_sub(remaining_lease, 0, 2)))%>%\n  mutate(remaining_lease_mth = as.integer(\n    str_sub(remaining_lease, 9, 11)))\n```\n:::\n\n\nWe narrow down the data scope to load into Onemap API later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_selected <- resale_tidy %>%\n  filter(month == \"2024-09\")\n```\n:::\n\n\nNext we extract the list of unique addresses from `resale_selected`. The list is sorted to ensure the first address is always picked up.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_list <- sort(unique(resale_selected$address))\n```\n:::\n\n\nThe below function read in any address list and record the coordinates of the parsed addresses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_coords <- function(add_list){\n  \n  # Create a data frame to store all retrieved coordinates\n  postal_coords <- data.frame()\n    \n  for (i in add_list){\n    #print(i)\n    # as the API provided code for 1 address search at a time only, for pasrsing a list of addresses we use the common/elastic/search syntax as below\n    r <- GET('https://www.onemap.gov.sg/api/common/elastic/search?',\n           query=list(searchVal=i,\n                     returnGeom='Y',\n                     getAddrDetails='Y'))\n    data <- fromJSON(rawToChar(r$content))\n    found <- data$found\n    res <- data$results\n    \n    # Create a new data frame for each address\n    new_row <- data.frame()\n    \n    # If single result, append \n    if (found == 1){\n      postal <- res$POSTAL \n      lat <- res$LATITUDE\n      lng <- res$LONGITUDE\n      new_row <- data.frame(address= i, \n                            postal = postal, \n                            latitude = lat, \n                            longitude = lng)\n    }\n    \n    # If multiple results, drop NIL and append top 1\n    else if (found > 1){\n      # Remove those with NIL as postal\n      res_sub <- res[res$POSTAL != \"NIL\", ]\n      \n      # Set as NA first if no Postal\n      if (nrow(res_sub) == 0) {\n          new_row <- data.frame(address= i, \n                                postal = NA, \n                                latitude = NA, \n                                longitude = NA)\n      }\n      \n      else{\n        top1 <- head(res_sub, n = 1)\n        postal <- top1$POSTAL \n        lat <- top1$LATITUDE\n        lng <- top1$LONGITUDE\n        new_row <- data.frame(address= i, \n                              postal = postal, \n                              latitude = lat, \n                              longitude = lng)\n      }\n    }\n\n    else {\n      new_row <- data.frame(address= i, \n                            postal = NA, \n                            latitude = NA, \n                            longitude = NA)\n    }\n    \n    # Add the row\n    postal_coords <- rbind(postal_coords, new_row)\n  }\n  return(postal_coords)\n}\n```\n:::\n\n\nWe run the get_coords function on the `add_list`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- get_coords(add_list)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(coords, \"data/rds/coords.rds\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}