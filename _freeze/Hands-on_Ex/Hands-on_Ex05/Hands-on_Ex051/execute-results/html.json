{
  "hash": "92c3784b81235a2ccd411c9b55c4cbbb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 5.1: Global Measures of Spatial Autocorrelation\"\nauthor: \"Nguyen Bao Thu Phuong\"\ndate: \"21 September 2024\" \ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n# Overview\n\nIn this hands-on exercise, we explore how to compute Global Measures of Spatial Autocorrelation (GMSA) using the `spdep` package. By the end of this exercise, you will be able to:\n\n-   Import geospatial data using functions from the `sf` package.\n\n-   Import a CSV file using the `readr` package.\n\n-   Perform relational joins with the `dplyr` package.\n\n-   Compute Global Spatial Autocorrelation (GSA) statistics using `spdep` functions.\n\n-   Plot a Moran scatterplot.\n\n-   Compute and visualize a spatial correlogram.\n\n-   Provide a statistically sound interpretation of GSA statistics.\n\n# Getting Started\n\n## The analytical question\n\nIn spatial policy, one of the main objectives for local governments and planners is to ensure the equitable distribution of development across a province. In this study, we aim to apply appropriate spatial statistical methods to determine whether development is evenly distributed geographically.\n\nIf development is not evenly distributed, the next question will be: **\"Is there evidence of spatial clustering?\"** If the answer is yes, we will then explore **\"Where are these clusters located?\"**\n\nFor this case study, we will examine the spatial pattern of a specific development indicator, **GDP per capita**, for Hunan Province in the People’s Republic of China.\n\n## The Study Area and Data\n\nTwo data sets will be used in this hands-on exercise, they are:\n\n-   Hunan province administrative boundary layer at county level. This geospatial data set is in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\n## Set the Analytical Tools\n\nBefore starting, ensure the **spdep**, **sf**, **tmap**, and **tidyverse** packages are installed:\n\n-   **sf**: for importing and handling geospatial data,\n\n-   **tidyverse**: for data wrangling,\n\n-   **spdep**: for spatial weights and autocorrelation statistics,\n\n-   **tmap**: for creating cartographic-quality choropleth maps.\n\nThe code below performs the following:\n\n-   Creates a list of required packages,\n\n-   Checks for missing packages and installs them if needed,\n\n-   Loads the packages into the R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\n```\n:::\n\n\n# Getting the Data Into R Environment\n\nIn this section, we explore how to bring a geospatial data and its associated attribute table into R environment. The geospatial data is in ESRI shapefile format and the attribute table is in csv fomat.\n\n## Import shapefile into r environment\n\nThe code chunk below uses `st_read()`of **sf** package to import Hunan shapefile into R. The imported shapefile will be in **simple features** object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\thuphuong1110\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex05\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n## Import csv file into r environment\n\nNext, we import *Hunan_2012.csv* into R by using read_csv() of **readr** package. The output is in R data frame class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n## Perform relational join\n\nThe code below updates the attribute table of Hunan’s **SpatialPolygonsDataFrame** by merging it with the attribute fields of the **hunan2012** dataframe, using the **left_join()** function from the **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(County)`\n```\n\n\n:::\n:::\n\n\n## Visualize Regional Development Indicator\n\nNow, we will create a basemap and a choropleth map to display the distribution of GDPPC in 2012 using the **qtm()** function from the **tmap** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex051_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n# Global Measures of Spatial Autocorrelation\n\nIn this section, we explore how to calculate global spatial autocorrelation statistics and conduct a spatial randomness test to assess global spatial autocorrelation.\n\n## Compute Contiguity Spatial Weights\n\nBefore computing global spatial autocorrelation statistics, we need to create spatial weights for the study area. Spatial weights define neighborhood relationships between geographical units, such as counties.\n\nIn the code below, the `poly2nb()` function from the `spdep` package computes contiguity weight matrices. It generates a neighbors list based on regions with shared boundaries. By default, the Queen contiguity rule is applied (neighboring regions share at least one point). You can specify `queen = FALSE` to use a different criterion, but without this argument, it defaults to the Queen method.\n\nThe code below calculates a Queen contiguity weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\nThe summary report indicates that Hunan has 88 area units. The most connected unit has 11 neighbors, while two units have only one neighbor each.\n\n## Row-standardised weights matrix\n\nTo assign weights to each neighboring polygon, we'll use equal weights (style = \"W\"). This approach gives each neighboring polygon a weight of 1 divided by the number of neighbors, then sums the weighted income values. While simple and intuitive, this method may misrepresent spatial autocorrelation, especially for edge polygons with fewer neighbors. For now, we'll stick with style = \"W,\" but more robust alternatives like style = \"B\" are available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n**Note:**\n\nThe `nb2listw()` function in R converts a neighbors list (an object of class `nb`) into a spatial weights object. It has two main arguments:\n\n-   **style**: This defines how weights are assigned. The options include:\n\n    -   \"B\": Basic binary coding (neighbors = 1, non-neighbors = 0).\n\n    -   \"W\": Row-standardized (weights sum to 1 for each row/neighborhood).\n\n    -   \"C\": Globally standardized (weights sum to 1 across all regions).\n\n    -   \"U\": Like \"C\" but scaled by the number of neighbors.\n\n    -   \"S\": Variance-stabilizing scheme (Tiefelsdorf et al. 1999).\n\n-   **zero.policy**: If `TRUE`, regions without neighbors are assigned zero weights, ensuring that their lagged values are zero.\n\n# Global Measures of Spatial Autocorrelation: Moran’s I\n\nIn this section, we explore how to perform Moran’s I statistics testing using moran.test() of **spdep**.\n\n## Moran’s I test\n\nThe code chunk below performs Moran’s I statistical testing using moran.test() of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n## Compute Monte Carlo Moran’s I\n\nThe following R code chunk conducts a permutation test for Moran's I statistic using the `moran.mc()` function from the `spdep` package. A total of 1000 simulations will be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n## Visualize Monte Carlo Moran’s I\n\nIt’s beneficial to closely examine the simulated Moran’s I test statistics. This can be done by plotting their distribution as a histogram using the code chunk below, which employs the `hist()` and `abline()` functions from R Graphics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01504572\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.004371574\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex051_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n# Global Measures of Spatial Autocorrelation: Geary’s \n\nIn this section, we explore how to perform Geary’s C statistics testing using appropriate functions of **spdep** package.\n\n## Geary’s C test\n\nThe code chunk below performs Geary’s C test for spatial autocorrelation using geary.test() of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n\n\n:::\n:::\n\n\n## Compute Monte Carlo Geary’s C\n\nThe code chunk below performs permutation test for Geary’s C statistic by using geary.mc() of **spdep**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n## Visualize the Monte Carlo Geary’s C\n\nNext, we use the code chunk below to plot a histogram and reveal the distribution of the simulated values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.004402\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.007436493\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex051_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n# Spatial Correlogram\n\nSpatial correlograms are excellent for examining spatial autocorrelation patterns in your data or model residuals. They plot an autocorrelation index (like Moran’s I or Geary’s c) against distance, showing how correlation changes with increasing distance (lag) between spatial observations. While not as fundamental as variograms in geostatistics, correlograms offer richer exploratory and descriptive insights.\n\n## Compute Moran’s I correlogram\n\nThe below code chunk uses sp.correlogram() of **spdep** package to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used is Moran’s I. `plot()` of base Graph is used to plot the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex051_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nPlotting the output alone may not provide a complete interpretation since not all autocorrelation values are statistically significant. Therefore, it’s crucial to examine the full analysis report by printing the analysis results using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n## Compute Geary’s C correlogram and plot\n\nIn the code chunk below, `sp.correlogram()` from the spdep package computes a 6-lag spatial correlogram of GDPPC using Geary’s C for global spatial autocorrelation. The `plot()` function from base Graph is then used to visualize the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex051_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nSimilar to the previous step, we print out the analysis report by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex051_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}