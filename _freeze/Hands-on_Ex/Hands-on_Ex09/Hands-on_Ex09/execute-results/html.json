{
  "hash": "73777d42b302de9b2ae81ad77d7b5e06",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 9: Modelling Geographical Accessibility\"\nauthor: \"Nguyen Bao Thu Phuong\"\ndate: \"26 October 2024\" \ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  message: false\n  freeze: true\n---\n\n\n# Overview\n\nIn this hands-on exercise, we'll explore how to model geographical accessibility using R’s geospatial analysis packages.\n\nBy the end of this exercise, you’ll be able to:\n\n-   Import GIS polygon data into R and save it as a simple feature data frame with functions from the **sf** package.\n\n-   Import aspatial data into R and similarly save it as a simple feature data frame with **sf** functions.\n\n-   Compute accessibility measures using Hansen’s potential model and the Spatial Accessibility Measure (SAM).\n\n-   Visualize accessibility measures with the **tmap** and **ggplot2** packages.\n\n# The Data\n\nThis hands-on exercise will utilize four data sets:\n\n1.  **MP14_SUBZONE_NO_SEA_PL**: GIS data for the URA Master Plan 2014 subzone boundaries, downloaded from data.gov.sg.\n\n2.  **Hexagons**: GIS data consisting of 250m radius hexagons, created using the `st_make_grid()` function from the `sf` package, and provided in ESRI shapefile format.\n\n3.  **ELDERCARE**: GIS data showing the locations of eldercare services, also downloaded from data.gov.sg. It includes two formats: ESRI shapefile (used for this exercise) and Google KML.\n\n4.  **OD_Matrix**: A CSV distance matrix with six fields:\n\n    -   **origin_id**: Unique identifier for the origin (`fid` of the hexagon data set).\n\n    -   **destination_id**: Unique identifier for the destination (`fid` of the ELDERCARE data set).\n\n    -   **entry_cost**: Perpendicular distance from the origin to the nearest road.\n\n    -   **network_cost**: Actual distance between the origin and destination.\n\n    -   **exit_cost**: Perpendicular distance from the destination to the nearest road.\n\n    -   **total_cost**: Sum of entry, network, and exit costs.\n\n    -   All values of cost related fields are in meters.\n\n**Note**: Except for the MP14_SUBZONE_NO_SEA_PL data set, the other three were specially prepared by Prof. Kam for teaching and research purposes. Students enrolled in Geospatial Analytics and Applications course may use them for hands-on exercises, but formal approval from Prof. Kam is required for any other use.\n\n# Getting Started\n\nBefore we begin, it’s essential to install the necessary R packages and load them into the RStudio environment. The following R packages are required for this exercise:\n\n-   Spatial Data Handling: `sf`\n\n-   Geographical Accessibility Modeling: `spatialAcc`\n\n-   Attribute Data Handling: `tidyverse` (especially `readr` and `dplyr`)\n\n-   Thematic Mapping: `tmap`\n\n-   Statistical Graphics: `ggplot2`\n\n-   Statistical Analysis: `ggstatsplot`\n\nThe code chunk below installs and loads these packages into RStudio:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, SpatialAcc, sf, \n               ggstatsplot, reshape2,\n               tidyverse)\n```\n:::\n\n\nNote that by loading **tidyverse**, there’s no need to install **readr, dplyr,** and **ggplot2** separately, as it includes additional packages such as **tidyr, stringr, forcats, tibble, purrr,** and **magrittr**.\n\n# Geospatial Data Wrangling\n\n## Import geospatial data\n\nWe will import three geospatial data sets from the data/geospatial sub-folder: `MP14_SUBZONE_NO_SEA_PL`, `hexagons`, and `ELDERCARE`. The code chunk below imports these shapefiles using the `st_read()` function from the **sf** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_NO_SEA_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_NO_SEA_PL' from data source \n  `C:\\thuphuong1110\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- st_read(dsn = \"data/geospatial\", layer = \"hexagons\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `hexagons' from data source \n  `C:\\thuphuong1110\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3125 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 21506.33 xmax: 50010.26 ymax: 50256.33\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geospatial\", layer = \"ELDERCARE\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `ELDERCARE' from data source \n  `C:\\thuphuong1110\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex09\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 120 features and 19 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 14481.92 ymin: 28218.43 xmax: 41665.14 ymax: 46804.9\nProjected CRS: SVY21 / Singapore TM\n```\n\n\n:::\n:::\n\n\nThe report indicates that the R object containing the imported `MP14_SUBZONE_WEB_PL` shapefile is named `mpsz`. It is a simple feature object with geometry type multipolygon. It is important to note that the `mpsz` simple feature object lacks EPSG information.\n\n## Update CRS information\n\nThe code chunk below updates the newly imported `mpsz` with the correct ESPG code (i.e. 3414)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_transform(mpsz, 3414)\neldercare <- st_transform(eldercare, 3414)\nhexagons <- st_transform(hexagons, 3414)\n```\n:::\n\n\nAfter transforming the projection metadata, we can verify the projection of the newly transformed `mpsz_svy21` using *st_crs()* of sf package as in below code chunk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n\n\n:::\n:::\n\n\nNotice that the EPSG is indicated as *3414* now.\n\n## Clean and Update attribute fields of the geospatial data\n\nMany redundant fields exist in both data tables `eldercare` and `hexagons`. The code chunks below excludes these redundant fields while adding two new fields: `demand` to the `hexagons` data table and `capacity` to the `eldercare` simple feature data frame. Both fields will be derived using the `mutate()` function from the **dplyr** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- eldercare %>%\n  select(fid, ADDRESSPOS) %>%\n  mutate(capacity = 100)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagons <- hexagons %>%\n  select(fid) %>%\n  mutate(demand = 100)\n```\n:::\n\n\nFor this hands-on exercise, a constant value of 100 is used for both the `capacity` and `demand` fields. In practice, actual demand for the hexagons and capacity for the eldercare centers should be applied.\n\n# Aspatial Data Handling and Wrangling\n\n## Import distance matrix\n\nThe code chunk below uses *read_cvs()* of **readr** package to import `OD_Matrix.csv` into RStudio as a tibble data.frame called `ODMatrix`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nODMatrix <- read_csv(\"data/aspatial/OD_Matrix.csv\", skip = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 375000 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (6): origin_id, destination_id, entry_cost, network_cost, exit_cost, tot...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n## Tidy distance matrix\n\nThe imported ODMatrix organised the distance matrix columnwise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ODMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  origin_id destination_id entry_cost network_cost exit_cost total_cost\n      <dbl>          <dbl>      <dbl>        <dbl>     <dbl>      <dbl>\n1         1              1       668.       19847.      47.6     20562.\n2         1              2       668.       45027.      31.9     45727.\n3         1              3       668.       17644.     173.      18486.\n4         1              4       668.       36010.      92.2     36770.\n5         1              5       668.       31068.      64.6     31801.\n6         1              6       668.       31195.     117.      31980.\n```\n\n\n:::\n:::\n\n\nHowever, most of the modelling packages in R is expecting a matrix look similar to the figure below.\n\n![](data/matrix screenshot.png)\n\nThe rows represent **origins** (also know as **from** field) and the columns represent **destination** (i.e. also known as **to** field.). The `pivot_wider()` function from the `tidyr` package was used to transform the O-D matrix from a long format to a wide format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat <- ODMatrix %>%\n  select(origin_id, destination_id, total_cost) %>%\n  pivot_wider(names_from = destination_id, values_from = total_cost)%>%\n  select(c(-c('origin_id')))\n```\n:::\n\n\nAs SVY21 projected coordinate system is used, the distance is measured in metre. The code chunk below converta the unit measurement from metre to kilometre.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistmat_km <- as.matrix(distmat/1000)\n```\n:::\n\n\n# Model and Visualize Accessibility using Hansen Method\n\n## Compute Hansen's accessibility\n\nNow we are ready to compute Hansen’s accessibility using the `ac()` function from the **SpatialAcc** package. Before proceeding, it's advisable to review the function's arguments at least once to ensure that all required inputs are available.\n\nThe code chunk below calculates Hansen’s accessibility, using `ac()` from the **SpatialAcc** package, and saves the output in a data frame called `acc_Hansen` using the `data.frame()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 2, \n                            family = \"Hansen\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ac.hexagons.demand..eldercare.capacity..distmat_km..power...2..\n1                                                    1.648313e-14\n2                                                    1.096143e-16\n3                                                    3.865857e-17\n4                                                    1.482856e-17\n5                                                    1.051348e-17\n6                                                    5.076391e-18\n```\n\n\n:::\n:::\n\n\nThe default field name is messy, we rename it to `accHansen` using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(acc_Hansen) <- \"accHansen\"\n```\n:::\n\n\nNotice that the field name is much more tidy now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(acc_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     accHansen\n1 1.648313e-14\n2 1.096143e-16\n3 3.865857e-17\n4 1.482856e-17\n5 1.051348e-17\n6 5.076391e-18\n```\n\n\n:::\n:::\n\n\nNext, we convert the data table into tibble format by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- as_tibble(acc_Hansen)\n```\n:::\n\n\nLastly, *bind_cols()* of **dplyr** is used to join the `acc_Hansen` tibble data frame with the `hexagons` simple feature data frame. The output is saved in `hexagon_Hansen`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\nNotice that `hexagon_Hansen` is a simple feature data frame and not a tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(hexagon_Hansen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 6 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 22756.33 xmax: 3244.888 ymax: 27756.33\nProjected CRS: SVY21 / Singapore TM\n  fid demand    accHansen                       geometry\n1   1    100 1.648313e-14 POLYGON ((2667.538 27506.33...\n2   2    100 1.096143e-16 POLYGON ((2667.538 25006.33...\n3   3    100 3.865857e-17 POLYGON ((2667.538 24506.33...\n4   4    100 1.482856e-17 POLYGON ((2667.538 24006.33...\n5   5    100 1.051348e-17 POLYGON ((2667.538 23506.33...\n6   6    100 5.076391e-18 POLYGON ((2667.538 23006.33...\n```\n\n\n:::\n:::\n\n\nThe steps above can be perform using a single code chunk as below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_Hansen <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            #d0 = 50,\n                            power = 0.5, \n                            family = \"Hansen\"))\n\ncolnames(acc_Hansen) <- \"accHansen\"\nacc_Hansen <- as_tibble(acc_Hansen)\nhexagon_Hansen <- bind_cols(hexagons, acc_Hansen)\n```\n:::\n\n\n## Visualize Hansen’s accessibility\n\n### Extract map extend\n\nFirst we extract the extend of `hexagons` simple feature data frame by using *st_bbox()* of **sf** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapex <- st_bbox(hexagons)\n```\n:::\n\n\nThe code chunk below uses a collection of mapping fucntions of **tmap** package to create a high cartographic quality accessibility to eldercare centre in Singapore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_Hansen,\n         bbox = mapex) + \n  tm_fill(col = \"accHansen\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: Hansen method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## Statistical graphic visualisation\n\nIn this section, we will compare the distribution of Hansen’s accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the `hexagon_Hansen` simple feature data frame using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_Hansen <- st_join(hexagon_Hansen, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\nNext, *ggplot()* will be used to plot the distribution by using boxplot graphical method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_Hansen, \n       aes(y = log(accHansen), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n# Model and Visualize Accessibility using KD2SFCA Method\n\n## Compute KD2SFCA’s accessibility\n\nIn this section, we will repeat most of the steps used in the previous section to conduct the analysis, with some code combined into a single code chunk.\n\nThe code chunk below calculates Hansen’s accessibility using the `ac()` function from the **SpatialAcc** package, and the output is saved in a data frame called `acc_KD2SFCA`. Note that `KD2SFCA` is specified for the `family` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            distmat_km, \n                            d0 = 50,\n                            power = 2, \n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- as_tibble(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n\n\n## Visualize KD2SFCA’s accessibility\n\nThe code chunk below uses a collection of mapping fucntions of **tmap** package to create a high cartographic quality accessibility to eldercare centre in Singapore. Notice that `mapex` is reused for *bbox* argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_KD2SFCA,\n         bbox = mapex) + \n  tm_fill(col = \"accKD2SFCA\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: KD2SFCA method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## Statistical graphic visualisation\n\nNow, we will compare the distribution of KD2CFA accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the `hexagon_KD2SFCA` simple feature data frame using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_KD2SFCA <- st_join(hexagon_KD2SFCA, mpsz, \n                          join = st_intersects)\n```\n:::\n\n\nNext, *ggplot()* will be used to plot the distribution by using boxplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_KD2SFCA, \n       aes(y = accKD2SFCA, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n# Model and Visualize Accessibility using Spatial Accessibility Measure (SAM) Method\n\n## Compute SAM Accessibility\n\nIn this section, we will repeat most of the steps learned in the previous section to perform the analysis, with some code combined into a single code chunk.\n\nThe code chunk below calculates Hansen’s accessibility using the `ac()` function from the `SpatialAcc` package, and the output is saved in a data frame called `acc_SAM`. Note that `SAM` is specified for the family argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_SAM <- data.frame(ac(hexagons$demand,\n                         eldercare$capacity,\n                         distmat_km, \n                         d0 = 50,\n                         power = 2, \n                         family = \"SAM\"))\n\ncolnames(acc_SAM) <- \"accSAM\"\nacc_SAM <- as_tibble(acc_SAM)\nhexagon_SAM <- bind_cols(hexagons, acc_SAM)\n```\n:::\n\n\n## Visualize SAM’s accessibility\n\nThe code chunk below uses a collection of mapping fucntions of **tmap** package to create a high cartographic quality accessibility to eldercare centre in Singapore. Notice that `mapex` is reused for *bbox* argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\ntmap mode set to plotting\n```\n\n\n:::\n\n```{.r .cell-code}\ntm_shape(hexagon_SAM,\n         bbox = mapex) + \n  tm_fill(col = \"accSAM\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(eldercare) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to eldercare: SAM method\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 3),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n## Statistical graphic visualisation\n\nNow, we will compare the distribution of SAM accessibility values by URA Planning Region.\n\nFirst, we need to add the planning region field to the `hexagon_SAM` simple feature data frame using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhexagon_SAM <- st_join(hexagon_SAM, mpsz, \n                       join = st_intersects)\n```\n:::\n\n\nNext, ggplot() will be used to plot the distribution using boxplot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hexagon_SAM, \n       aes(y = accSAM, \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in geom_point(stat = \"summary\", fun.y = \"mean\", colour = \"red\", :\nIgnoring unknown parameters: `fun.y`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo summary function supplied, defaulting to `mean_se()`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex09_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}